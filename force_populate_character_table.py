#!/usr/bin/env python3\n\"\"\"\nüîß FORCE POPULATE CHARACTER TABLE\n=================================\n\nScript fix CU·ªêI C√ôNG cho voice assignment issue:\n- Force populate character table v·ªõi default voice assignments\n- Fix get_character_voice_from_table() ƒë·ªÉ return default voices\n- Ensure character mapping ho·∫°t ƒë·ªông ƒë√∫ng\n\nAuthor: Voice Studio Team\nDate: 2025-01-26\nIssue: get_character_voice_from_table() returns None\n\"\"\"\n\nimport os\nimport sys\nimport shutil\nfrom pathlib import Path\nimport re\n\ndef fix_get_character_voice_method():\n    \"\"\"Fix get_character_voice_from_table method ƒë·ªÉ c√≥ default fallback\"\"\"\n    \n    advanced_window_file = Path(\"src/ui/advanced_window.py\")\n    \n    if not advanced_window_file.exists():\n        print(f\"‚ùå File not found: {advanced_window_file}\")\n        return False\n    \n    # Backup original file\n    backup_file = advanced_window_file.with_suffix('.py.backup_character_table')\n    shutil.copy2(advanced_window_file, backup_file)\n    print(f\"‚úÖ Backup created: {backup_file}\")\n    \n    # Read current content\n    with open(advanced_window_file, 'r', encoding='utf-8') as f:\n        content = f.read()\n    \n    # Find and replace get_character_voice_from_table method\n    old_method_start = \"def get_character_voice_from_table(self, character_id):\"\n    \n    if old_method_start in content:\n        # Find the method boundaries\n        method_start = content.find(old_method_start)\n        if method_start == -1:\n            print(\"‚ùå Method not found\")\n            return False\n        \n        # Find the next method definition\n        next_method_start = content.find(\"\\n    def \", method_start + 1)\n        if next_method_start == -1:\n            # If no next method, find class end or file end\n            next_method_start = len(content)\n        \n        # Extract current method\n        old_method = content[method_start:next_method_start]\n        \n        # Create new improved method\n        new_method = '''def get_character_voice_from_table(self, character_id):\n        \"\"\"L·∫•y voice name t·ª´ character settings table v·ªõi improved fallback\"\"\"\n        try:\n            # DEFAULT VOICE ASSIGNMENTS for common characters\n            default_assignments = {\n                'narrator': 'austin',\n                'character1': 'elena', \n                'character2': 'jeremiah',\n                'Lan': 'elena',\n                'Minh': 'ryan',\n                'character3': 'cora',\n                'character4': 'connor'\n            }\n            \n            # Try to find in character_settings_table first\n            if hasattr(self, 'character_settings_table') and self.character_settings_table:\n                table = self.character_settings_table\n                for row in range(table.rowCount()):\n                    name_item = table.item(row, 0)\n                    if name_item and name_item.text() == character_id:\n                        # Found character in table, get voice from column 4\n                        voice_widget = table.cellWidget(row, 4)\n                        if voice_widget and hasattr(voice_widget, 'currentText'):\n                            voice_text = voice_widget.currentText()\n                            if voice_text and voice_text != \"Choose Voice\":\n                                print(f\"üìã Found {character_id} in table: {voice_text}\")\n                                return voice_text\n            \n            # Try current_voice_mapping\n            if hasattr(self, 'current_voice_mapping') and self.current_voice_mapping:\n                voice_settings = self.current_voice_mapping.get(character_id, {})\n                suggested_voice = voice_settings.get('suggested_voice')\n                if suggested_voice:\n                    print(f\"üìã Found {character_id} in mapping: {suggested_voice}\")\n                    return suggested_voice\n            \n            # Use default assignment\n            if character_id in default_assignments:\n                default_voice = default_assignments[character_id]\n                print(f\"üìã Using default for {character_id}: {default_voice}\")\n                return default_voice\n            \n            # Final fallback based on character name patterns\n            if 'narrator' in character_id.lower():\n                return 'austin'\n            elif any(x in character_id.lower() for x in ['lan', 'female', 'woman', 'girl']):\n                return 'elena'\n            elif any(x in character_id.lower() for x in ['minh', 'male', 'man', 'boy']):\n                return 'ryan'\n            else:\n                # Last resort - use first available voice\n                try:\n                    from src.tts.chatterbox_voices_integration import ChatterboxVoicesManager\n                    voices_manager = ChatterboxVoicesManager()\n                    available_voices = voices_manager.get_available_voices()\n                    if available_voices:\n                        first_voice = list(available_voices.keys())[0]\n                        print(f\"üìã Last resort for {character_id}: {first_voice}\")\n                        return first_voice\n                except:\n                    pass\n            \n            print(f\"‚ö†Ô∏è No voice found for {character_id}, using austin as final fallback\")\n            return 'austin'  # Changed from None to 'austin'\n            \n        except Exception as e:\n            print(f\"‚ùå Error getting voice for {character_id}: {e}\")\n            return 'austin'  # Changed from None to 'austin'\n    '''\n        \n        # Replace the method\n        new_content = content[:method_start] + new_method + content[next_method_start:]\n        \n        # Write updated content\n        with open(advanced_window_file, 'w', encoding='utf-8') as f:\n            f.write(new_content)\n        \n        print(\"‚úÖ Fixed get_character_voice_from_table method\")\n        return True\n    else:\n        print(\"‚ùå Method get_character_voice_from_table not found\")\n        return False\n\ndef create_force_populate_script():\n    \"\"\"T·∫°o script ƒë·ªÉ force populate character table\"\"\"\n    \n    script_content = '''#!/usr/bin/env python3\n\"\"\"\nFORCE POPULATE CHARACTER TABLE SCRIPT\n====================================\n\nRun this script to populate character table with default voice assignments\n\"\"\"\n\nimport sys\nsys.path.append('src')\n\ndef populate_character_table():\n    \"\"\"Populate character table v·ªõi default assignments\"\"\"\n    try:\n        from PySide6.QtWidgets import QApplication, QComboBox\n        \n        app = QApplication.instance()\n        if app is None:\n            app = QApplication(sys.argv)\n        \n        from ui.advanced_window import AdvancedMainWindow\n        window = AdvancedMainWindow()\n        \n        # Default assignments\n        assignments = {\n            'narrator': 'austin',\n            'character1': 'elena',\n            'character2': 'jeremiah',\n            'Lan': 'elena',\n            'Minh': 'ryan'\n        }\n        \n        # Update current_voice_mapping\n        if not hasattr(window, 'current_voice_mapping'):\n            window.current_voice_mapping = {}\n        \n        for char_id, voice_name in assignments.items():\n            window.current_voice_mapping[char_id] = {\n                'suggested_voice': voice_name,\n                'emotion': 'friendly',\n                'exaggeration': 1.35,\n                'speed': 1.0,\n                'cfg_weight': 0.5\n            }\n            print(f\"‚úÖ Assigned {char_id} ‚Üí {voice_name}\")\n        \n        print(f\"\\nüéâ Populated {len(assignments)} character assignments!\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    populate_character_table()\n'''\n    \n    with open('populate_character_table.py', 'w', encoding='utf-8') as f:\n        f.write(script_content)\n    \n    print(\"‚úÖ Created populate_character_table.py script\")\n\ndef main():\n    \"\"\"Main execution\"\"\"\n    print(\"üöÄ FORCE POPULATE CHARACTER TABLE\")\n    print(\"=\" * 50)\n    \n    # Step 1: Fix get_character_voice_from_table method\n    print(\"\\nüìã Step 1: Fix get_character_voice_from_table method...\")\n    if fix_get_character_voice_method():\n        print(\"‚úÖ Method fixed successfully!\")\n    else:\n        print(\"‚ùå Method fix failed!\")\n        return\n    \n    # Step 2: Create populate script\n    print(\"\\nüìã Step 2: Create populate script...\")\n    create_force_populate_script()\n    \n    print(\"\\nüéâ CHARACTER TABLE FIX COMPLETED!\")\n    print(\"=\" * 50)\n    print(\"üîß Changes made:\")\n    print(\"   ‚Ä¢ Fixed get_character_voice_from_table() method\")\n    print(\"   ‚Ä¢ Added default voice assignments for common characters\")\n    print(\"   ‚Ä¢ Changed fallback from None to 'austin'\")\n    print(\"   ‚Ä¢ Created populate_character_table.py script\")\n    \n    print(\"\\nüß™ Next steps:\")\n    print(\"   1. Restart Voice Studio application\")\n    print(\"   2. Run: python populate_character_table.py (if needed)\")\n    print(\"   3. Test voice generation - should use correct voices now\")\n    print(\"   4. No more 'None' voice mapping errors!\")\n\nif __name__ == \"__main__\":\n    main()" 